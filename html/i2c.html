<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hwlib: i2c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="hwlib_icon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hwlib
   </div>
   <div id="projectbrief">C++ OO-style close-to-the-hardware library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('i2c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">i2c </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="i2c-hardware"></a>
hardware</h1>
<p>In its simplest form, an i2c bus has one master and a number of slaves that are connected by two wires: SCL (clock) and SDA (data). Both lines are pulled up by pull-up resistor, and can (only) be pulled down by a connected chip (open-collector, hwlib pin type pin_oc).</p>
<div class="image">
<img src="i2c-bus.png" alt="i2c-bus.png"/>
</div>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-transaction-format"></a>
transaction formats</h1>
<p>An i2c transaction is either a read transaction or a write transaction. In both cases, the transaction starts with the master transmitting a control byte, which contains the address of the slave chip, and one bit that indicates whether it is a read or a write transaction. The bits of a byte are transferred MSB (most significant bit) first.</p>
<div class="image">
<img src="i2c-command-1.png" alt="i2c-command-1.png"/>
</div>
<div class="image">
<img src="i2c-command-2.png" alt="i2c-command-2.png"/>
</div>
<p>Next the slave chip receives (write transaction) or transmits (read transaction) as many bytes as the master asks for.</p>
<div class="image">
<img src="i2c-write-read.png" alt="i2c-write-read.png"/>
</div>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-bits"></a>
bit-level signaling</h1>
<p>At the bit level, master generates clock pulses by pulling the SCL line low. While the SCL is low, the master or slave can put a bit on the SDA line by pulling it down (for a 0) or letting it float (for a 1).</p>
<p>The SCL line is always driven by the master (unless the slave uses clock-stretching), the SDA line is driven by the device on the bus that sends the bit.</p>
<div class="image">
<img src="i2c-bit-level.png" alt="i2c-bit-level.png"/>
</div>
<p>Two special conditions are used. To signal the start (S) of a transaction, the sda is pulled low while the clk is high. The reverse is used to indicate a stop (P, the end of a transaction): the dta is released (goes high) while the clock is high.</p>
<div class="image">
<img src="i2c-signaling.png" alt="i2c-signaling.png"/>
</div>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-addressing"></a>
addressing within a slave</h1>
<p>Simple slave chips that have only one data byte that can be read or written using a single-byte read or write transaction to read or write that data byte.</p>
<p>Slave chips that have more than one address that can be written often use a write transaction where the first byte(s) written determine the address (within the slave chip), and the subsequent byte(s) are written to that address (and to the next addresses).</p>
<p>An I2C read transaction addresses the slave chip, but has no provision to specify an address within the slave chip. The common trick is that a read addresses the last address specified by a (previous) write transaction. Hence to read from address X first a write is done to address X, but the transaction stops after the X. Hence nothing is written, but this sets the address pointer inside the slave chip. Now a read transaction reads from this address.</p>
<p>As always, consult the datasheet of the chip for the details!</p>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-ownership"></a>
I2C ownership</h1>
<p>The I2C bus was invented by Philips, who had a patent on it. Hence other manufacturers that implemented the I2C bus on their chips had either to pay royalties to Philips, or tried to avoid this by implementing a protocol that was compatible with I2C, without mentioning I2C. The I2C patent has expired, but you can still find many chips that are described as 'implementing a two-wire protocol' or something similar. In most cases this means that the chip implements I2C.</p>
<p>references:</p><ul>
<li><a href="http://www.nxp.com/documents/user_manual/UM10204.pdf">I2C bus specification and user manual (pdf)</a></li>
<li><a href="http://i2c.info/i2c-bus-specification">I2C Bus Specification (info page)</a></li>
<li><a href="https://en.wikipedia.org/wiki/I2C">I2C Bus (wikipedia)</a></li>
</ul>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-bus"></a>
i2c bus</h1>
<p>An i2c bus object represents an i2c bus. An i2c bus can be used (in order of preference)</p><ul>
<li>by creating a channel to a slave and using the operations of that channel</li>
<li>by read or write transactions or a transaction object, which specify the slave</li>
<li>through its primitives</li>
</ul>
<table class="doxtable">
<tr>
<th>i2c bus attributes and functions </th><th>use  </th></tr>
<tr>
<td>channel( s ) </td><td>creates a channel to slave s </td></tr>
<tr>
<td>read( s, d ) </td><td>performs a single byte read transaction </td></tr>
<tr>
<td>read( s, d, n ) </td><td>performs an n byte read transaction </td></tr>
<tr>
<td>write( s, d ) </td><td>performs a single byte write transaction </td></tr>
<tr>
<td>write( s, d, n ) </td><td>performs an n byte write transaction </td></tr>
<tr>
<td>transactions.read( s ) </td><td>creates a read transaction </td></tr>
<tr>
<td>transactions.write( s ) </td><td>creates a write transaction </td></tr>
<tr>
<td>primitives </td><td>low-level operations </td></tr>
</table>
<p>The read and write operations are easier to use than a transaction, but require the data to be read or written is one contiguous block.</p>
<p>A bit-banged i2c bus implementation is provided. An object of this class is constructed from the two pins (scl and scd), which must be pin_oc pins.</p>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-channel"></a>
i2c channel</h1>
<p>An i2c channel abstracts the communication over an i2c bus to a specific slave. An i2c channel is created from an i2c bus by providing the slave address.</p>
<p>An i2c channel can be used (in order of preference)</p><ul>
<li>by read or write transactions on a single byte or a block of bytes</li>
<li>by creating a read or write transaction and using the operations of that transaction</li>
<li>through its primitives (which are same as the i2c bus primitives)</li>
</ul>
<p>The read and write operations are easier to use than a transaction, but require the data to be read or written is one contiguous block.</p>
<table class="doxtable">
<tr>
<th>i2c channel attributes and functions </th><th>use  </th></tr>
<tr>
<td>read( d ) </td><td>performs a single byte read transaction </td></tr>
<tr>
<td>read( d, n ) </td><td>performs an n byte read transaction </td></tr>
<tr>
<td>write( d ) </td><td>performs a single byte write transaction </td></tr>
<tr>
<td>write( d, n ) </td><td>performs an n byte write transaction </td></tr>
<tr>
<td>transactions.read() </td><td>creates a read transaction </td></tr>
<tr>
<td>transactions.write() </td><td>creates a write transaction </td></tr>
<tr>
<td>primitives </td><td>low-level operations </td></tr>
</table>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-transactions"></a>
i2c transactions</h1>
<p>An i2c transaction encompasses a complete read or write transaction. A transaction is created from an i2c_bus object and the slave address. The transaction can be used to read (for a read transaction) or write (for a write transaction) data. A transaction allows for multiple read or write operations within a single transaction. A transaction is started (control byte send) by the transaction constructor. A transaction is closed (final NACK send) by the transaction destructor.</p>
<table class="doxtable">
<tr>
<th>i2c read transaction functions </th><th>use  </th></tr>
<tr>
<td>read_byte() </td><td>performs a single byte read </td></tr>
<tr>
<td>read( d, n ) </td><td>performs an n byte read </td></tr>
</table>
<p><br />
</p>
<table class="doxtable">
<tr>
<th>i2c write transaction functions </th><th>use  </th></tr>
<tr>
<td>write( d ) </td><td>performs a single byte write </td></tr>
<tr>
<td>write(const uint8_t data[],size_t n) </td><td>performs an n byte write </td></tr>
</table>
<p><br />
 </p><hr/>
<h1><a class="anchor" id="i2c-primitives"></a>
i2c primitives</h1>
<p>The class i2c_primitives abstracts the primitive i2c operations, from which the higher-level read and write transactions are implemented. These are the operations that must be implemented by an i2c implementation.</p>
<p>As an i2c user, you should probably never use these functions.</p>
<table class="doxtable">
<tr>
<th>function </th><th>use  </th></tr>
<tr>
<td>hwlib::i2c_primitives::read_ack read_ack() </td><td>read and return an (expected) ack bit </td></tr>
<tr>
<td>hwlib::i2c_primitives::write_ack write_ack() </td><td>write an ack bit </td></tr>
<tr>
<td>hwlib::i2c_primitives::write_nack write_nack() </td><td>read and ack bit </td></tr>
<tr>
<td>hwlib::i2c_primitives::write(uint8_t) write( b ) </td><td>write one byte (8 bits) </td></tr>
<tr>
<td>hwlib::i2c_primitives::read_byte read_byte() </td><td>read one byte (8 bits) </td></tr>
<tr>
<td>hwlib::i2c_primitives::write write(uint8_t data[],size_t n) </td><td>write n bytes (from d ) </td></tr>
<tr>
<td>hwlib::i2c_primitives::read read( d, n ) </td><td>read n bytes (into d) </td></tr>
</table>
<p><br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 1 2019 16:30:59 for hwlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
